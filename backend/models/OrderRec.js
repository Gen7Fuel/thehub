const mongoose = require('mongoose');

/**
 * ItemSchema
 * Represents a single item in an order reconciliation category.
 */
const ItemSchema = new mongoose.Schema({
  gtin: { type: String, required: true },           // Global Trade Item Number
  vin: { type: String, default: '' },               // Vendor Item Number
  itemName: { type: String, default: '' },          // Name of the item
  size: { type: String, default: '' },              // Size/packaging of the item
  onHandQty: { type: Number, default: 0 },          // Current on-hand quantity
  onHandQtyOld: { type: Number, default: 0 },       // Previous on-hand quantity
  forecast: { type: Number, default: 0 },           // Forecasted quantity
  minStock: { type: Number, default: 0 },           // Minimum stock level
  itemsToOrder: { type: Number, default: 0 },       // Number of items to order
  unitInCase: { type: Number, default: 0 },         // Units per case
  casesToOrder: { type: Number, default: 0 },       // Number of cases to order
  casesToOrderOld: { type: Number, default: 0 },    // Previous number of cases to order
  completed: { type: Boolean, default: false }      // Whether this item is completed
});

/**
 * CategorySchema
 * Represents a category within an order reconciliation, containing multiple items.
 */
const CategorySchema = new mongoose.Schema({
  number: { type: String, required: true },         // Category number/identifier
  name: { type: String, required: true },           // Category name
  items: [ItemSchema],                              // Array of items in this category
  completed: { type: Boolean, default: false }      // Whether this category is completed
});

/**
 * CommentSchema
 * Represents a comment on an order reconciliation.
 */
const CommentSchema = new mongoose.Schema({
  text: { type: String, required: true },           // Comment text
  author: { type: String },                         // Author's email or user id
  timestamp: { type: Date, default: new Date() }    // When the comment was made
});

/**
 * StatusHistorySchema
 * Represents a status change event in the order reconciliation's lifecycle.
 */
const StatusHistorySchema = new mongoose.Schema({
  status: { type: String, required: true },         // Status name
  timestamp: { type: Date }                         // When the status was set
});

/**
 * OrderReconciliationSchema
 * Main schema for an order reconciliation document.
 * Represents a full order reconciliation for a site and vendor.
 */
const OrderReconciliationSchema = new mongoose.Schema({
  filename: { type: String },                       // Autogenerated filename for the order rec
  categories: [CategorySchema],                     // Array of categories in the order rec
  createdAt: { type: Date, default: Date.now },     // Creation timestamp
  integerId: { type: Number, unique: true },        // Unique integer ID (autoincremented)
  site: { type: String, required: true },           // Site/location identifier
  vendor: { type: String, required: true },         // Vendor identifier (can be ObjectId or name)
  completed: { type: Boolean, default: false },     // Whether the order rec is completed
  extraItemsNote: { type: String, default: '' },    // Notes for extra items
  email: { type: String, default: 'mohammad@gen7fuel.com' }, // Creator's email
  orderPlaced: { type: Boolean, default: false },   // Whether the order has been placed
  delivered: { type: Boolean, default: false },     // Whether the order has been delivered
  currentStatus: { type: String, default: "Created" }, // Current status of the order rec
  statusHistory: {
    type: [StatusHistorySchema],
    default: [{ status: "Created", timestamp: new Date() }]
  },                                                // Array of status history events
  comments: {
    type: [CommentSchema],
    default: []
  }                                                 // Array of comments
});

/**
 * Pre-save hook to auto-generate integerId and filename before saving.
 * - integerId: increments from the last used integerId.
 * - filename: formatted as "OrderRec - VendorName - Date - integerId".
 */
OrderReconciliationSchema.pre('save', async function (next) {
  if (!this.integerId) {
    const last = await mongoose.model('OrderReconciliation').findOne({}, {}, { sort: { integerId: -1 } });
    this.integerId = last ? last.integerId + 1 : 1;
  }
  if (!this.filename) {
    let vendorName = this.vendor;
    // If vendor is an ObjectId, try to populate and get the name
    if (mongoose.isValidObjectId(this.vendor)) {
      // Try to fetch the vendor document and get its name
      try {
        const Vendor = mongoose.model('Vendor');
        const vendorDoc = await Vendor.findById(this.vendor);
        if (vendorDoc && vendorDoc.name) {
          vendorName = vendorDoc.name;
        }
      } catch (e) {
        // fallback to ObjectId string if lookup fails
      }
    }
    const dateStr = formatDateWithSuffix(this.createdAt);
    this.filename = `OrderRec - ${vendorName} - ${dateStr} - ${this.integerId}`;
  }
  next();
});

/**
 * Helper function to format a date with a day suffix (e.g., "1st January 2024").
 * @param {Date} date
 * @returns {string}
 */
function formatDateWithSuffix(date) {
  const day = date.getDate();
  const suffix =
    day % 10 === 1 && day !== 11 ? 'st' :
    day % 10 === 2 && day !== 12 ? 'nd' :
    day % 10 === 3 && day !== 13 ? 'rd' : 'th';
  const month = date.toLocaleString('default', { month: 'long' });
  const year = date.getFullYear();
  return `${day}${suffix} ${month} ${year}`;
}

// Export the OrderReconciliation model based on the schema
module.exports = mongoose.model('OrderReconciliation', OrderReconciliationSchema);